eclipse.preferences.version=1
org.eclipse.mylyn.java.ui.run.count.3_10_0=1
org.eclipse.mylyn.java.ui.run.count.3_1_0=1
javapackage message;

public class OneByteInt {
	private int value;
	
	public OneByteInt(int value){
		this.value = value;
	}
	public void setValue(int value){
		this.value = value;
	}
	
	public int getValue(){
		return this.value;
	}
}
package message;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class ByteUnpacker {
	private ArrayList<String> properties;
	private HashMap <String, TYPE> propToValue;
	
	public ByteUnpacker(){
		properties = new ArrayList<>();
		propToValue = new HashMap<>();
	}
	
	public ByteUnpacker defineComponents(ByteUnpacker unpacker){
		if(unpacker!=null){
			properties.addAll(unpacker.properties);
			propToValue.putAll(unpacker.propToValue);
		}
		return this;
	}
	/***
	 *Identify data structure type for each property using hashmap built from defineComponents()
	 *Scan byte array using hashmap to build a new hashmap containing key and actual values
	 * 
	 * @param data
	 * @return
	 */
	public UnpackedMsg parseByteArray(byte[] data){
		int offset = 0;
		HashMap<String, Object> map = new HashMap<>();
		try{
			for(String property: properties){
				TYPE value = propToValue.get(property);
				switch(value){
				case INTEGER:
					map.put(property, parseInt(data, offset));
					offset+=4;
					break;
				case DOUBLE:
					map.put(property, parseDouble(data,offset));
					offset+=8;
					break;
				case STRING:
					int length = parseInt(data, offset);
                    map.put(property, parseString(data, offset + 4, length));
                    offset += 4 + length;
                    break;
				case BYTE_ARRAY:
					int byte_length = parseInt(data, offset);
                    map.put(property, Arrays.copyOfRange(data, offset + 4, offset + 4 + byte_length));
					break;
				case ONE_BYTE_INT:
					map.put(property, new OneByteInt(data[offset] & 0xFF));
                    offset += 1;
                    break;
				}
			}
			UnpackedMsg result = new UnpackedMsg(map);
			return result;
		}catch(Exception e){
			return null;
		}
	}
	
	private String parseString(byte[] data, int offset, int length) {
		try{
			StringBuilder sb = new StringBuilder();
			for(int i=0;i<length;i++,offset++){
				sb.append((char)data[offset]);
			}
			return sb.toString();
		}catch(IndexOutOfBoundsException e){
			return null;
		}
		
	}

	private Double parseDouble(byte[] data, int offset) {
		int doubleSize = 8;
		byte[] temp = new byte[doubleSize];
		for(int i =0;i<doubleSize;i++){
			temp[i] = data[offset+i];
		}
		double value = ByteBuffer.wrap(temp).getDouble();
		return value;
	}

	private Integer parseInt(byte[] data, int offset) {
		int intSize = 4;
		byte[] temp = new byte[intSize];
		for(int i=0;i<intSize;i++){
			temp[i] = data[offset+i];
		}
		
		int value = ByteBuffer.wrap(temp).getInt();
		return value;
	}

	
	
	public static class UnpackedMsg{
		private HashMap<String, Object> map;
		
		public UnpackedMsg(HashMap<String,Object> map){
			this.map = map;
		}
		
		public Integer getInteger(String key){
			if(map.containsKey(key) && (map.get(key) instanceof Integer)){
				return (Integer) map.get(key);
			}
			return null;
		}
		public String getString(String key){
			if(map.containsKey(key) && map.get(key) instanceof String){
				return (String) map.get(key);
			}
			return null;
		}
		public Double getDouble(String key){
			if(map.containsKey(key) && map.get(key) instanceof Double){
				return (Double) map.get(key);
			}
			return null;
		}
		public byte[] getByteArray(String value) {
            if (map.containsKey(value) && map.get(value) instanceof byte[]) {
                return (byte[]) map.get(value);
            }
            return null;
        }

        public OneByteInt getOneByteInt(String value) {
            if (map.containsKey(value) && map.get(value) instanceof OneByteInt) {
                return (OneByteInt) map.get(value);
            }
            return null;
        }
	}
	
	
	
	
	public enum TYPE {
        INTEGER, DOUBLE, STRING, BYTE_ARRAY, ONE_BYTE_INT
    }
	
	public static class Builder{
		private ByteUnpacker unpacker;
		public Builder(){
			unpacker = new ByteUnpacker();
			
		}
		public Builder setType(String property, TYPE type){
			unpacker.properties.add(property);
			unpacker.propToValue.put(property, type);
			return this;
		}
		public ByteUnpacker build(){
			return unpacker;
		}
	}
}
package message;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;

/***
 * BytePackerClass is the class that does the marshalling. 
 * Converts objects into bytes before storing the bytes in a byte array. 
 * Order at which objects are stored in byte[] depends on the order of the Keys in the ArrayList properties
 * @author Shide
 *
 */
public class BytePacker {
	private ArrayList<String> properties;
	private HashMap<String, Object> propToValue;
	public BytePacker(){
		properties = new ArrayList<>();
		propToValue = new HashMap<>();
	}
	public void setValue(String key, Object value){
		properties.add(key);
		propToValue.put(key,value);
	}
	
	public Object getValue(String key){
		return propToValue.get(key);
	}
	
	public byte[] getByteArray(){
		/*
        Calculate the size required for the byte array
        based on the type of the object
        Integer     4 bytes
        String      4 + length of string bytes (+4 in front is to store the length of the string)
        Long        8 bytes
        Byte Array  4 + length of byte array
        float 		4 bytes
        double 		8 bytes
        OneByteInt  1 byte
		*/
		int size = 1;
		for(Object value: propToValue.values()){
			if(value instanceof Integer){
				size+=4;
			}
			else if(value instanceof String){
				size += 4 + ((String) value).length(); 
			}
			else if (value instanceof Double){
				size+= 8;
			}
			else if(value instanceof byte[]){
				size+= 4 + ((byte[]) value).length;
			}
			else if(value instanceof OneByteInt){
				size +=1;
			}
		}
		byte[] buffer = new byte[size];
		
		
		int index = 0;
		for(String property: properties){
			Object value = propToValue.get(property);
			if(value instanceof Integer){
				index = intToByte((Integer)value, buffer, index); /*Converts Integer to byte*/
			}
			else if(value instanceof String){
				index = intToByte(((String) value).length(), buffer, index); /*1st integer is length of string*/
				index = stringToByte(((String)value), buffer,index);		/*Convert the content of string to bytes*/
			}
			else if(value instanceof Double){
				index = doubleToByte((Double)value,buffer,index);		/*Convert double to bytes*/
			}
			else if(value instanceof byte[]){
				index = intToByte(((byte[]) value).length, buffer,index); /*First int is length of byte array*/
				System.arraycopy(value, 0, buffer, index, ((byte[])value).length); /*Copy contents of byte array into buffer*/
				index+= ((byte[]) value).length;
			}else if(value instanceof OneByteInt){
				int OBIValue = ((OneByteInt) value).getValue();
				buffer[index++] = (byte) (OBIValue & 0xFF);
			}
			
		}
		
		return buffer;
	}
	
	private int intToByte(int i, byte[] buffer, int index){
		/*buffer[index++] = (byte)((i>>24) & 0xFF);
		buffer[index++] = (byte)((i>>16) & 0xFF);
		buffer[index++] = (byte)((i>>8) & 0xFF);
		buffer[index++] = (byte)((i) & 0xFF);*/
		
		byte[] temp = new byte[4];
		ByteBuffer.wrap(temp).putInt(i);
		for(byte b: temp){
			buffer[index++] = b;
		}
		
		return index;
	}
	private int stringToByte(String s, byte[] buffer, int index){
		for(byte b: s.getBytes()){
			buffer[index++] = b;
		}
		return index;
	}
	private int doubleToByte(Double d, byte[] buffer, int index){
		byte[] temp = new byte[8];
		ByteBuffer.wrap(temp).putDouble(d);
		for(byte b: temp){
			buffer[index++] = b;
		}
		return index;
	}
	
	/***
	 * Builder class for BytePackerClass
	 * 
	 * 
	 */
	public static class Builder{
		private BytePacker packer;
		
		public Builder(){
			packer = new BytePacker();
		}
		
		public Builder setProperty(String key, int value){
			return set(key,value);
		}
		
		public Builder setProperty(String key, double value){
			return set(key, value);
		}
		
		public Builder setProperty(String key, String string){
			return set(key, string);
		}
		
		public Builder setProperty(String key, OneByteInt value){
			return set(key,value);
		}
		
		public Builder set(String key, Object value){
			packer.setValue(key,value);
			return this;
		}
		
		public BytePacker build(){
			return packer;
		}
	}
}

package main;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.ThreadLocalRandom;

import message.BytePacker;
import services.Service;
import socket.CorruptedSocket;
import socket.NormalSocket;
import socket.ReceivingLossSocket;
import socket.SendingLossSocket;
import socket.Socket;

public class Client {
	public static final int CREATE_ACCOUNT = 0; /*Service ID used to associate which service to call when msg gets transmitted*/
	public static final int CLOSE_ACCOUNT = 1;
	//public static final int MAKE_DEPOSIT = 2;
	public static final int UPDATE_BALANCE = 2;
	public static final int TRANSFER_BALANCE = 3;
	public static final int REGISTER_CALLBACK = 4;
	public static final int CHECK_BALANCE = 5;
	public static final int BUFFER_SIZE = 2048;
	
	private Socket designatedSocket = null;
	private HashMap<Integer, Service> idToServiceMap; /*Hashmap containing the serviceId and corresponding service*/
	private String serverIpAddress;
	private int serverPortNumber;
	private InetAddress InetIpAddress = null;
	private int message_id;
	private int timeout;
	//buffer
    private byte[] buffer = new byte[BUFFER_SIZE];
	
	public Client(String ipAddress, int portNumber, int timeout) throws UnknownHostException, SocketException{
		this.idToServiceMap = new HashMap<>();
		this.serverIpAddress = ipAddress;
		this.InetIpAddress = InetAddress.getByName(ipAddress);
		this.designatedSocket = new NormalSocket(new DatagramSocket());
		this.serverPortNumber = portNumber;
		this.timeout = timeout; //Datagramsocket timeout on receive functions, in ms. 
		this.designatedSocket.setTimeOut(timeout);
		this.message_id = 0;
	}
	
	public int getMessage_id() {
		return message_id++;
	}

	public void setMessage_id(int message_id) {
		this.message_id = message_id;
	}
	
	
	public void addService(int serviceId, Service service){
		idToServiceMap.put(serviceId, service);
	}
	
	public void execute(int id,Console console) throws IOException{
		if(idToServiceMap.containsKey(id)){
			Service service = this.idToServiceMap.get(id);
			service.executeRequest(console, this);
		}
	}
	public void send(BytePacker packer) throws IOException{
		this.designatedSocket.send(packer, this.InetIpAddress, this.serverPortNumber);
	}
	
	public DatagramPacket receive() throws IOException{
		Arrays.fill(buffer,(byte) 0);
		DatagramPacket p = new DatagramPacket(buffer,buffer.length);
		this.designatedSocket.receive(p);
		return p;	
	}
	
	public Socket getDesignatedSocket(){
		return this.designatedSocket;
	}
	
	public int getTimeout(){
		return this.timeout;
	}
	
	
	public void useReceivingLossSocket(double probability){
		this.designatedSocket = new ReceivingLossSocket(this.designatedSocket,probability);
	}
	
	public void useSendingLossSocket(double probability){
		this.designatedSocket = new SendingLossSocket(this.designatedSocket, probability);
	}
	
	public void useCorruptedSocket(double probability){
		this.designatedSocket = new CorruptedSocket(this.designatedSocket, probability);
	}
	
	public void printMenu(){
		for(Integer serviceId : idToServiceMap.keySet()){
			Console.println(String.format("%d: %s", serviceId, idToServiceMap.get(serviceId).ServiceName()));
		}
	}
	
	
}
package main;

import java.io.IOException;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Scanner;

import services.CheckBalanceService;
import services.CloseAccountService;
import services.CreateAccountService;
import services.RegisterCallbackService;
import services.BalanceTransfer;
import services.BalanceUpdate;



public class Application {
	public static void main(String[] args){
		
		Console console = new Console(new Scanner(System.in));
		String serverIpAddress = console.askForString("Input server ip address:"); //need to change if using a different computer on the network
		int serverPortNumber = console.askForInteger("Input server port number"); //designated port number
		int timeout = console.askForInteger("Input socket timeout");
				
		try {
			Client client = new Client(serverIpAddress, serverPortNumber, timeout*1000);
			
			//add available service
			client.addService(0, new CreateAccountService());
			client.addService(1, new CloseAccountService());
			client.addService(2, new BalanceUpdate());
			client.addService(3, new BalanceTransfer());
			client.addService(4, new RegisterCallbackService());
			client.addService(5, new CheckBalanceService());
			
			//Console.debug_info = false;
			/*Specify what type of socket to use*/
			int socketType = console.askForInteger(1, 4, "Select Socket Type: \n1)Normal Socket\n2)SendingLossSocket\n3)ReceivingLossSocket\n4)CorruptedSocket");
			if(socketType!=1){
				 double probability = 1.0 - console.askForDouble(0.0, 1.0, "Probability of packetloss:");
				 //System.out.println("socketType:" + socketType);
				 if(socketType == 2){
					 client.useSendingLossSocket(probability);
				 } 
				 else if(socketType==3){
					 client.useReceivingLossSocket(probability);
				 }else if(socketType == 4){
					 client.useCorruptedSocket(probability);
				 }
			 }	

			
			while(true){
				client.printMenu();
				int serviceNumber = console.askForInteger("Enter service request: ");
				if(serviceNumber ==-1) break;
				client.execute(serviceNumber, console);
			}
			
		} catch (UnknownHostException | SocketException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
	}
	
}
package main;
import java.util.Scanner;

/***
 * This class is in charged of printing results on the console.
 * 
 * @author Shide
 *
 */
public class Console {
	private Scanner scanner;
	static boolean debug_info = true;

	public Console(Scanner scanner) {
		this.scanner = scanner;
	}

	public static void println(String str) {
		System.out.println(str);
	}

	public static void debug(String str) {
		if (debug_info)
			System.out.println(str);
	}

	/**
	 * Prompt User to key in integer of choices
	 *
	 * @param question
	 *            A string of question to ask user for input
	 * @return user input
	 */
	public int askForInteger(String question) {
		System.out.println(question);
		return askForInteger();
	}

	/**
	 * This method read Client's input of integer
	 *
	 * @return Integer if user key in correctly, error message otherwise
	 */
	public int askForInteger() {
		while (true) {
			try {
				return Integer.parseInt(scanner.nextLine());
			} catch (NumberFormatException ignored) {
			}
		}
	}

	public double askForDouble(String question) {
		System.out.println(question);
		return askForDouble();
	}

	public double askForDouble() {
		while (true) {
			try {
				return Double.parseDouble(scanner.nextLine());
			} catch (NumberFormatException ignored) {
			}
		}
	}

	public String askForString(String question) {
		System.out.println(question);
		return scanner.nextLine();
	}
	public int askForInteger(int min, int max, String question){
		System.out.println(question);
		int choice = min;
		while(true){
			try{
				choice = Integer.parseInt(scanner.nextLine());
				if(choice >= min && choice <=max){
					return choice;
				}
				else{
					System.out.println("Invalid Choice");
					System.out.println(question);
				}
			}catch(NumberFormatException ignored){}
		}
	}
	public double askForDouble(double min, double max, String question){
		System.out.println(question);
		double choice = min;
		while(true){
			try{
				choice = Double.parseDouble(scanner.nextLine());
				if(choice >= min && choice <=max){
					return choice;
				}
				else{
					System.out.println("Invalid Choice");
					System.out.println(question);
				}
			}catch(NumberFormatException ignored){}
		}
	}
}
package services;

import java.io.IOException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;

public class BalanceUpdate extends Service {
		
	public BalanceUpdate() {
		super(null);
	}
	
	public void executeRequest(Console console, Client client) throws IOException{
		Console.println("---------------------Balance Update---------------------------------");
		String name = console.askForString("Enter your name:");
		int accNum = console.askForInteger("Enter your Account Number:");
		int pin = console.askForInteger("Input your 6 digit pin-number:");
		int choice = console.askForInteger("Do you want to deposit(1) or withdraw(0):"); 
		double amount = console.askForDouble("Enter amount to deposit/withdraw:");
		int message_id = client.getMessage_id();	/*This should only be called once for each executeRequest as the message_id will be incremented each time  this method is called*/
		
		BytePacker packer = new BytePacker.Builder()
								.setProperty("ServiceId", new OneByteInt(Client.UPDATE_BALANCE))
								.setProperty("messageId", message_id)
								.setProperty("Name", name)
								.setProperty("accNum", accNum)
								.setProperty("Pin", pin)
								.setProperty("choice", choice)
								.setProperty("amount", amount)
								.build();
		client.send(packer);
		
		ByteUnpacker.UnpackedMsg unpackedMsg = receivalProcedure(client, packer, message_id);
		if(checkStatus(unpackedMsg)){
			String reply = unpackedMsg.getString(Service.REPLY);
			Console.println(reply);	
		}
		else{
			Console.println("Balance Update failed");
		}
	}
	@Override
	public String ServiceName() {
		return "Make Deposit/Withdrawal";
	}
}
package services;

import java.io.IOException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;

public class CreateAccountService extends Service {

	protected final static String NAME = "Name";
	protected final static String PIN = "Pin";
	protected final static String CURRENCY = "Currency";
	protected final static String BALANCE = "Balance";
	
	public CreateAccountService(){
		super(null);
	}
	
	/***
	 * Account creation: 
	 * Required details - 1) Name (string), 2) Password (6 digit integer), 3) Currency type (string), 4) Initial Balance (Double)
	 * @throws IOException 
	 */
	@Override
	public void executeRequest(Console console, Client client) throws IOException {
		Console.println("---------------------Account creation---------------------------------");
		String name = console.askForString("Enter your name:");
		int pin = console.askForInteger("Input your 6 digit pin-number:");
		String currency = console.askForString("Specify currency type:");
		double init_balance = console.askForDouble("Enter initial balance:");

		/*returns current messageId value before incrementing it */
		int message_id = client.getMessage_id();	
		
		/*Carry out marshalling, store values for each field in request*/
		BytePacker packer = new BytePacker.Builder()
								.setProperty(Service.SERVICE_ID, new OneByteInt(Client.CREATE_ACCOUNT))
								.setProperty(Service.MESSAGE_ID, message_id)
								.setProperty(NAME, name)
								.setProperty(PIN, pin)
								.setProperty(CURRENCY,currency)
								.setProperty(BALANCE, init_balance)
								.build();
		client.send(packer);
		
		ByteUnpacker.UnpackedMsg unpackedMsg = receivalProcedure(client, packer, message_id);
		
		/*Check if reply status is 0. 0 means success. */
		if(checkStatus(unpackedMsg)){ 
			
			String reply = unpackedMsg.getString(Service.REPLY);
			Console.println(reply);
		}
		else{
			Console.println("Account create failed");
		}
	}
	
	@Override
	public String ServiceName() {
		return "Create Account";
	}

}
package services;

import java.io.IOException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;

public class CheckBalanceService extends Service {
	
	protected final static String ACC_NUMBER = "AccountNumber";
	protected final static String PIN = "Pin";

	public CheckBalanceService() {
		super(null);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void executeRequest(Console console, Client client) throws IOException {
		// TODO Auto-generated method stub
		Console.println("---------------------Check Balance---------------------------------");
		int accNum = console.askForInteger("Input account number: ");
		int pin = console.askForInteger("Input pin number:");
		int messageId = client.getMessage_id();
		BytePacker packer = new BytePacker.Builder()
							.setProperty(Service.SERVICE_ID,new OneByteInt(Client.CHECK_BALANCE))
							.setProperty(Service.MESSAGE_ID, messageId)
							.setProperty(ACC_NUMBER, accNum)
							.setProperty(PIN, pin)
							.build();
		client.send(packer);
		ByteUnpacker.UnpackedMsg unpackedMsg = receivalProcedure(client, packer, messageId);
		if(checkStatus(unpackedMsg)){
			String reply = unpackedMsg.getString(Service.REPLY);
			Console.println(reply);
		}
		
		
	}

	@Override
	public String ServiceName() {
		return "Check Balance";
	}	
	
	

}
package services;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketTimeoutException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.NormalSocket;
import socket.Socket;
import socket.WrapperSocket;

public abstract class Service {
	
	private final ByteUnpacker unpacker;
	protected static final String STATUS = "status";
	protected static final String SERVICE_ID = "serviceId";
    protected static final String MESSAGE_ID = "messageId";
    protected static final String REPLY = "reply";
	
	protected Service(ByteUnpacker unpacker){
		this.unpacker = new ByteUnpacker.Builder()
						.setType(STATUS, ByteUnpacker.TYPE.ONE_BYTE_INT)
						.setType(MESSAGE_ID, ByteUnpacker.TYPE.INTEGER)
						.setType(REPLY, ByteUnpacker.TYPE.STRING)
						.build()
						.defineComponents(unpacker);
	}
	
	/**
	 * @param client
	 * @param packer request that was just sent out, now waiting for reply from server
	 * @param message_id id of request sent out
	 * @return Unpacked message once received from server. message_id in msg from server must match param message_id
	 * @throws IOException
	 */
	public final ByteUnpacker.UnpackedMsg receivalProcedure(Client client, BytePacker packer, int message_id ) throws IOException{
		while(true){
			try{
				DatagramPacket reply = client.receive();
				ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(reply.getData());
				if(checkMsgId(message_id,unpackedMsg)){
					return unpackedMsg;
				}		
			}catch (SocketTimeoutException e){
				Console.debug("Socket timeout.");
				client.send(packer);
			}
		}
	}
	public final boolean checkMsgId(Integer message_id, ByteUnpacker.UnpackedMsg unpackedMsg){
		Integer return_message_id = unpackedMsg.getInteger(MESSAGE_ID);
		Console.debug("return_message_id: " + return_message_id);
		Console.debug("message_id: " + message_id);
		if(return_message_id != null){
			return message_id == return_message_id;
		}
		return false;
	}
	
	public final boolean checkStatus(ByteUnpacker.UnpackedMsg unpackedMsg){
		OneByteInt status = unpackedMsg.getOneByteInt(STATUS);
		Console.debug("Status: " + status.getValue());
		if(status.getValue()==0)return true; //0 means no error? okay. 
		return false;
	}
	
	public final boolean checkStatus(ByteUnpacker.UnpackedMsg unpackedMsg, int replyStatus){
		OneByteInt status = unpackedMsg.getOneByteInt(STATUS);
		if(status.getValue()==replyStatus)return true; //0 means no error? okay. 
		return false;
	}
	
	
	public ByteUnpacker getUnpacker() {
		return unpacker;
	}
	
	public abstract void executeRequest(Console console, Client client) throws IOException;
	public abstract String ServiceName(); 
	
}
package services;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.SocketTimeoutException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;

public class RegisterCallbackService extends Service{
	
	protected final static String TIMEOUT = "timeout";
	public RegisterCallbackService(){
		super(null);
	}

	@Override
	public void executeRequest(Console console, Client client) throws IOException {
		Console.println("---------------------Register Auto-monitoring---------------------------------");
		int timeout = console.askForInteger("Enter monitor interval:");
		int message_id = client.getMessage_id();	/*This should only be called once for each executeRequest as the message_id will be incremented each time  this method is called*/
		BytePacker packer = new BytePacker.Builder()
								.setProperty(Service.SERVICE_ID, new OneByteInt(Client.REGISTER_CALLBACK))
								.setProperty(Service.MESSAGE_ID, message_id)
								.setProperty(TIMEOUT, timeout)
								.build();
		client.send(packer);
		
		//Wait for reply from server that says callback registered, then enter auto monitoring state
		ByteUnpacker.UnpackedMsg unpackedMsg = receivalProcedure(client, packer, message_id);
		if(checkStatus(unpackedMsg)){
			String reply = unpackedMsg.getString(Service.REPLY);
			Console.println(reply);
			
			/*
			 * Inside here, have while loop that runs infinitely, 
			 * call receive receive receive until 1 msg that has status 4 which means auto-monitoring expired.
			 * */
			while(true){
				client.getDesignatedSocket().setTimeOut(0);
				ByteUnpacker.UnpackedMsg callbackMsg = callbackUpdatesHandler(client, message_id, super.getUnpacker());
				String callbackMsgReply = callbackMsg.getString(Service.REPLY);
				Console.println(callbackMsgReply);
				if(checkStatus(callbackMsg,4)){
					client.getDesignatedSocket().setTimeOut(client.getTimeout());
					break;
				}
			}
		}
	
	}
	public ByteUnpacker.UnpackedMsg callbackUpdatesHandler(Client client, int message_id, ByteUnpacker unpacker) throws IOException{
		while(true){
			try{
				DatagramPacket reply = client.receive();
				ByteUnpacker.UnpackedMsg unpackedMsg = unpacker.parseByteArray(reply.getData());
				if(checkMsgId(message_id,unpackedMsg)) return unpackedMsg;
			}catch (SocketTimeoutException e){
				//If socket receive function timeout, catch exception, resend request. Stays here until reply received? okay. 
				Console.debug("Socket timeout exception in callbackUpdates handler");
				
			}
		}
	
	}
	
	@Override
	public String ServiceName() {
		return "Register Callback";
	}
	
	
	

}
package services;

import java.io.IOException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;

public class CloseAccountService extends Service {

	protected final static String NAME = "Name";
	protected final static String ACCNUM = "accNum";
	protected final static String PIN = "Pin";

	public CloseAccountService(){
		super(null);
	}
	
	/***
	 * Account creation: 
	 * Required details - 1) Name (string), 2) Password (6 digit integer), 3) Currency type (string?), 4) Initial Balance (Double)
	 * @throws IOException 
	 */
	@Override
	public void executeRequest(Console console, Client client) throws IOException {
		Console.println("---------------------Account deletion---------------------------------");
		String name = console.askForString("Enter your name:");
		int accNum = console.askForInteger("Input your account number:");
		int pin = console.askForInteger("Input your 6 digit pin-number:");
		int message_id = client.getMessage_id();	/*This should only be called once for each executeRequest as the message_id will be incremented each time  this method is called*/
		BytePacker packer = new BytePacker.Builder()
								.setProperty(Service.SERVICE_ID, new OneByteInt(Client.CLOSE_ACCOUNT))
								.setProperty(Service.MESSAGE_ID, message_id)
								.setProperty(NAME, name)
								.setProperty(ACCNUM, accNum)
								.setProperty(PIN, pin)
								.build();
		client.send(packer);
		
		ByteUnpacker.UnpackedMsg unpackedMsg = receivalProcedure(client, packer, message_id);
		if(checkStatus(unpackedMsg)){ //Check if reply status is 0. 0 means success. 
			//String accNum = unpackedMsg.getString(Service.REPLY);
			//Console.println("Account successfully created.");
			//Console.println("Account number: " + accNum);	
			String reply = unpackedMsg.getString(Service.REPLY);
			Console.println(reply);
		}
		else{
			Console.println("Account close failed");
		}
	}
	
	@Override
	public String ServiceName() {
		return "Close Account";
	}
}
package services;

import java.io.IOException;

import main.Client;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;

public class BalanceTransfer extends Service {
		
	public BalanceTransfer() {
		super(null);
	}
	
	public void executeRequest(Console console, Client client) throws IOException{
		Console.println("---------------------Balance Transfer---------------------------------");
		String name = console.askForString("Enter your name:");
		int accNum = console.askForInteger("Enter your Account Number:");
		int pin = console.askForInteger("Input your 6 digit pin-number:");
		int receiver = console.askForInteger("Enter Account Number of Recipient:");
		double amount = console.askForDouble("Enter amount to transfer:");
		int message_id = client.getMessage_id();	/*This should only be called once for each executeRequest as the message_id will be incremented each time  this method is called*/
		
		BytePacker packer = new BytePacker.Builder()
								.setProperty("ServiceId", new OneByteInt(Client.TRANSFER_BALANCE))
								.setProperty("messageId", message_id)
								.setProperty("Name", name)
								.setProperty("accNum", accNum)
								.setProperty("Pin", pin)
								.setProperty("receiver", receiver)
								.setProperty("amount", amount)
								.build();
		client.send(packer);
		
		ByteUnpacker.UnpackedMsg unpackedMsg = receivalProcedure(client, packer, message_id);
		if(checkStatus(unpackedMsg)){
			String reply = unpackedMsg.getString(Service.REPLY);
			Console.println(reply);	
		}
		else{
			Console.println("Transfer failed");
		}
	}
	
	@Override
	public String ServiceName() {
		return "Transfer Funds";
	}
}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;

import message.BytePacker;

public class WrapperSocket implements Socket {
	private final Socket socket;
	
	public WrapperSocket(Socket socket){
		this.socket = socket;
	}
	
	@Override
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {

		this.socket.send(msg, address, port);
		
	}

	@Override
	public void receive(DatagramPacket p) throws IOException {
		this.socket.receive(p);
	}

	@Override
	public void close() {
		this.socket.close();
		
	}

	@Override
	public void setTimeOut(int timeout) throws SocketException {
		// TODO Auto-generated method stub
		this.socket.setTimeOut(timeout);
		
	}
	
	public Socket getSocket(){
		return socket;
	}


}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.SocketTimeoutException;
import java.util.Random;

import main.Console;

/**
 * Simulate packet loss when receiving
 * 
 * @author Shide
 *
 */
public class ReceivingLossSocket extends WrapperSocket {
	private Random random;
	private double probability;
	
	public ReceivingLossSocket(Socket socket, double probability){
		super(socket);
		this.random = new Random();
		this.probability = probability;
	}
	
	public void receive(DatagramPacket p) throws IOException, SocketTimeoutException{
		if(random.nextDouble()<this.probability){
			super.receive(p);
		}
		else{
			try {
				Thread.sleep(200);
				Console.debug("Simulate packetloss when receiving");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}throw new SocketTimeoutException();
		}
	}
}
package socket;

import java.io.IOException;
import java.net.InetAddress;
import java.util.Random;

import main.Console;
import message.BytePacker;

/**
 * 
 * Simulate packet loss when sending packets out, based on a defined probability
 * @author Shide
 *
 */
public class SendingLossSocket extends WrapperSocket {
	
	private final Random random;
	private final double probability;
	public SendingLossSocket(Socket socket, double probability) {
		super(socket);
		this.random = new Random();
		this.probability = probability;
		// TODO Auto-generated constructor stub
	}
	
	/**
	 * Use probability to simulate packetloss
	 * higher prob --> higher probability of sending. lower packetloss
	 * 
	 */
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {
		if(random.nextDouble()<probability){
			super.send(msg, address, port);
		}
		else{
			try{
				Thread.sleep(1000);
				Console.debug("Simulate Packet loss on Sending");
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
	

}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.util.Random;

import main.Console;
import message.BytePacker;

public class CorruptedSocket extends WrapperSocket{
	
	private final double probability;
	private final Random random;
	public CorruptedSocket(Socket socket, double probability) {
		super(socket);
		this.random = new Random();
		this.probability = probability;
	}
	
	public void corruptData(byte[] message){
		this.random.nextBytes(message);
	}
	
	@Override
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {
		byte[] msgByte = msg.getByteArray();
		if(random.nextDouble()>probability){	
			Console.debug("sending corrupted data");
			corruptData(msgByte);
		}
		NormalSocket socket = (NormalSocket) (this.getSocket());
		DatagramPacket p = new DatagramPacket(msgByte, msgByte.length,address, port);
		socket.send(p);
	}
	@Override
    public void receive(DatagramPacket p) throws IOException {
        super.receive(p);
        if (random.nextDouble()>probability) {
        	Console.debug("receiving corrupted data");
        	corruptData(p.getData());
        }
    }
	
}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;

import message.BytePacker;

public interface Socket {
	void send(BytePacker msg ,InetAddress address, int port) throws IOException;
	void receive(DatagramPacket p) throws IOException;
	void close();
	void setTimeOut(int timeout) throws SocketException;
}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

import main.Console;
import message.BytePacker;


public class NormalSocket implements Socket {
	
	private DatagramSocket socket;
	
	public NormalSocket(DatagramSocket socket){
		this.socket = socket;
	}
	
	@Override
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {
		Console.debug("Sending message");
		byte[] message = msg.getByteArray();
		DatagramPacket p = new DatagramPacket(message, message.length,address, port);
		send(p);
		return;
	}

	@Override
	public void receive (DatagramPacket p) throws IOException {
		// TODO Auto-generated method stub
		this.socket.receive(p);
		Console.debug("Receiving message from server");
		return;
	}

	@Override
	public void close() {
		Console.debug("Closing socket");
		// TODO Auto-generated method stub
		this.socket.close();
		return;
	}

	@Override
	public void setTimeOut(int timeout) throws SocketException {
		this.socket.setSoTimeout(timeout);
	}

	public DatagramSocket getSocket() {
		return socket;
	}

	public void setSocket(DatagramSocket socket) {
		this.socket = socket;
	}
	
	public void send(DatagramPacket p) throws IOException{
		this.socket.send(p);
	}
	
	
}
package bank;

public class Account {
	private int accNumber;
	private String accOwner;
	private int accPin;
	private String accCurrency;
	private double accBalance;
	
	public Account(){}
	public Account(int accNumber, String accOwner, int accPin, String accCurrency, double accBalance) {
		this.accNumber = accNumber;
		this.accOwner = accOwner;
		this.accPin = accPin;
		this.accCurrency = accCurrency;
		this.accBalance = accBalance;
	}
	
	public int getAccNumber() {
		return accNumber;
	}
	public void setAccNumber(int accNumber) {
		this.accNumber = accNumber;
	}
	public String getAccOwner() {
		return accOwner;
	}
	public void setAccOwner(String accOwner) {
		this.accOwner = accOwner;
	}
	public String getAccCurrency() {
		return accCurrency;
	}
	public void setAccCurrency(String accCurrency) {
		this.accCurrency = accCurrency;
	}
	public double getAccBalance() {
		return accBalance;
	}
	public void setAccBalance(double accBalance) {
		this.accBalance = accBalance;
	}
	
	public int getAccPin() {
		return accPin;
	}

	public void setAccPin(int accPin) {
		this.accPin = accPin;
	}



	public static class Builder{
		private Account account;
		public Builder(){
			account = new Account();
		}
		public Builder setAccNumber(int accNumber){
			account.setAccNumber(accNumber);
			return this;
		}
		public Builder setAccOwner(String accOwner){
			account.setAccOwner(accOwner);
			return this;
		}
		public Builder setAccBalance(double accBalance){
			account.setAccBalance(accBalance);
			return this;
		}
		public Builder setAccCurrency(String accCurrency){
			account.setAccCurrency(accCurrency);
			return this;
		}
		public Builder setAccPin(int pin){
			account.setAccPin(pin);
			return this;
		}
		
		public Account build(){
			return account;
		}
	}
}
package bank;

import java.util.HashMap;
import java.util.concurrent.ThreadLocalRandom;

import main.Console;

public class Bank {
	public static HashMap<Integer, Account> AllTheAccounts;
	public Bank(){
		AllTheAccounts = new HashMap<>();
	}
	
	
	public static int createAccount(String accOwner, int pin, String accCurrency, double accBalance){
		//Generate account number. For now...Use size of hash map. Account number should be an integer. 
		int accNum = -1;
		int min = 1000;
		int max = 9999;
		do{
			accNum = ThreadLocalRandom.current().nextInt(min, max);
		}while(AllTheAccounts.get(accNum)!=null);
		//int accNum = AllTheAccounts.size()+1;
		Account newAcc = new Account.Builder()
						.setAccOwner(accOwner)
						.setAccPin(pin)
						.setAccNumber(accNum)
						.setAccCurrency(accCurrency)
						.setAccBalance(accBalance)
						.build();
		AllTheAccounts.put(accNum, newAcc);
		Console.debug("Account created, acc num: " + accNum);
		return accNum;
	}
	
	public static double checkBalance(int accNum, int pin){
		double balance = 0;
		Account acc = AllTheAccounts.get(accNum);
		if(acc!=null){
			if(acc.getAccPin() == pin){
				balance = acc.getAccBalance();
			}
			else balance = -2; //balance == -2 : invalid pin
		}
		else{
			balance = -1; //balance == -1 : account does not exist
		}
		return balance;
	}
	
	public static double updateBalance(String accOwner, int accNum, int pin, int choice, double amount){
		//Account temp = AllTheAccounts.get(accNum);
		System.out.println("choice " + choice);
		//Check to see if account exists
		if(AllTheAccounts.get(accNum)==null)return -1;
		//Check to see if pin number matches record
		if(AllTheAccounts.get(accNum).getAccPin() != pin)return -2;
		
		//choice = 1 means user wants to deposit money
		if(choice == 1){
			Account temp = AllTheAccounts.get(accNum);
			temp.setAccBalance(temp.getAccBalance() + amount);		
		}
		//withdraw money
		else if(choice==0){
			Account temp = AllTheAccounts.get(accNum);
			//Check to see if account has enough money to withdraw
			if(temp.getAccBalance() > amount){
				temp.setAccBalance(temp.getAccBalance() - amount);
				Console.debug("Account's balance is " + temp.getAccBalance());
			}		
			else {
				Console.debug("Account's balance is not enough. " + temp.getAccBalance());
				return -3;
			}
		}
		else return -4; //Invalid choice	
		
		System.out.println(AllTheAccounts.get(accNum).getAccBalance());		
		return AllTheAccounts.get(accNum).getAccBalance();
	}
	
	public static int closeAccount(String accOwner, int accNum, int pin){
		Account temp = AllTheAccounts.get(accNum);
		if(temp!=null){
			Console.debug("Not null");
			if(temp.getAccPin()==pin){
				AllTheAccounts.remove(accNum);
				return 1;
			}
			else{
				return -2;
			}
		}
		else{
			Console.debug("hmmmm");
			return -1;
		}
	}
	public static double transferBalance(String accOwner, int accNum, int receiver, int pin, double amount){
		
		Account senderAcc, receiverAcc;

		if(AllTheAccounts.get(accNum) == null || AllTheAccounts.get(receiver) == null) {
			return -1;
		}
		
		senderAcc = AllTheAccounts.get(accNum);
		receiverAcc = AllTheAccounts.get(receiver);
		
		if(senderAcc.getAccPin() != pin) {
			return -2; //incorrect pin
		}
		
		
		if(senderAcc.getAccBalance() > amount) {
			senderAcc.setAccBalance(senderAcc.getAccBalance() - amount);
			receiverAcc.setAccBalance(receiverAcc.getAccBalance() + amount);
			System.out.println(AllTheAccounts.get(accNum).getAccBalance());
			System.out.println(AllTheAccounts.get(receiver).getAccBalance());
			return senderAcc.getAccBalance();
		}
		else{
			return -3; //insufficient funds
		}
				
		
	}
	
}
package message;

public class OneByteInt {
	private int value;
	
	public OneByteInt(int value){
		this.value = value;
	}
	public void setValue(int value){
		this.value = value;
	}
	
	public int getValue(){
		return this.value;
	}
}
package message;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class ByteUnpacker {
	private ArrayList<String> properties;
	private HashMap <String, TYPE> propToValue;
	
	public ByteUnpacker(){
		properties = new ArrayList<>();
		propToValue = new HashMap<>();
	}
	
	public ByteUnpacker defineComponents(ByteUnpacker unpacker){
		if(unpacker!=null){
			properties.addAll(unpacker.properties);
			propToValue.putAll(unpacker.propToValue);
		}
		return this;
	}
	/***
	 *Identify data structure type for each property using hashmap built from defineComponents()
	 *Scan byte array using hashmap to build a new hashmap containing key and actual values
	 * 
	 * @param data
	 * @return
	 */
	public UnpackedMsg parseByteArray(byte[] data){
		int offset = 0;
		HashMap<String, Object> map = new HashMap<>();
		try{
			for(String property: properties){
				TYPE value = propToValue.get(property);
				switch(value){
				case INTEGER:
					map.put(property, parseInt(data, offset));
					offset+=4;
					break;
				case DOUBLE:
					map.put(property, parseDouble(data,offset));
					offset+=8;
					break;
				case STRING:
					int length = parseInt(data, offset);
                    map.put(property, parseString(data, offset + 4, length));
                    offset += 4 + length;
                    break;
				case BYTE_ARRAY:
					int byte_length = parseInt(data, offset);
                    map.put(property, Arrays.copyOfRange(data, offset + 4, offset + 4 + byte_length));
					break;
				case ONE_BYTE_INT:
					map.put(property, new OneByteInt(data[offset] & 0xFF));
                    offset += 1;
                    break;
				}
			}
			UnpackedMsg result = new UnpackedMsg(map);
			return result;
		}catch(Exception e){
			return null;
		}
	}
	
	private String parseString(byte[] data, int offset, int length) {
		try{
			StringBuilder sb = new StringBuilder();
			for(int i=0;i<length;i++,offset++){
				sb.append((char)data[offset]);
			}
			return sb.toString();
		}catch(IndexOutOfBoundsException e){
			return null;
		}
		
	}

	private Double parseDouble(byte[] data, int offset) {
		int doubleSize = 8;
		byte[] temp = new byte[doubleSize];
		for(int i =0;i<doubleSize;i++){
			temp[i] = data[offset+i];
		}
		double value = ByteBuffer.wrap(temp).getDouble();
		return value;
	}

	private Integer parseInt(byte[] data, int offset) {
		int intSize = 4;
		byte[] temp = new byte[intSize];
		for(int i=0;i<intSize;i++){
			temp[i] = data[offset+i];
		}
		
		int value = ByteBuffer.wrap(temp).getInt();
		return value;
	}

	
	
	public static class UnpackedMsg{
		private HashMap<String, Object> map;
		
		public UnpackedMsg(HashMap<String,Object> map){
			this.map = map;
		}
		
		public Integer getInteger(String key){
			if(map.containsKey(key) && (map.get(key) instanceof Integer)){
				return (Integer) map.get(key);
			}
			return null;
		}
		public String getString(String key){
			if(map.containsKey(key) && map.get(key) instanceof String){
				return (String) map.get(key);
			}
			return null;
		}
		public Double getDouble(String key){
			if(map.containsKey(key) && map.get(key) instanceof Double){
				return (Double) map.get(key);
			}
			return null;
		}
		public byte[] getByteArray(String value) {
            if (map.containsKey(value) && map.get(value) instanceof byte[]) {
                return (byte[]) map.get(value);
            }
            return null;
        }

        public OneByteInt getOneByteInt(String value) {
            if (map.containsKey(value) && map.get(value) instanceof OneByteInt) {
                return (OneByteInt) map.get(value);
            }
            return null;
        }
	}
	
	
	
	
	public enum TYPE {
        INTEGER, DOUBLE, STRING, BYTE_ARRAY, ONE_BYTE_INT
    }
	
	public static class Builder{
		private ByteUnpacker unpacker;
		public Builder(){
			unpacker = new ByteUnpacker();
			
		}
		public Builder setType(String property, TYPE type){
			unpacker.properties.add(property);
			unpacker.propToValue.put(property, type);
			return this;
		}
		public ByteUnpacker build(){
			return unpacker;
		}
	}
}
package message;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;

import message.BytePacker.Builder;

/***
 * BytePackerClass is the class that does the marshalling. 
 * Converts objects into bytes before storing the bytes in a byte array. 
 * Order at which objects are stored in byte[] depends on the order of the Keys in the ArrayList properties
 * @author Shide
 *
 */
public class BytePacker {
	private ArrayList<String> properties;
	private HashMap<String, Object> propToValue;
	
	public BytePacker(){
		properties = new ArrayList<>();
		propToValue = new HashMap<>();
		
	}
	public void setValue(String key, Object value){
		properties.add(key);
		propToValue.put(key,value);
	}
	
	public Object getValue(String key){
		return propToValue.get(key);
	}
	
	public HashMap<String,Object> getPropToValue(){
		return this.propToValue;
	}
	
	public byte[] getByteArray(){
		/*
        Calculate the size required for the byte array
        based on the type of the object
        Integer     4 bytes
        String      4 + length of string bytes (+4 in front is to store the length of the string)
        Long        8 bytes
        Byte Array  4 + length of byte array
        float 		4 bytes
        double 		8 bytes
        OneByteInt  1 byte
		*/
		int size = 1;
		for(Object value: propToValue.values()){
			if(value instanceof Integer){
				size+=4;
			}
			else if(value instanceof String){
				size += 4 + ((String) value).length(); 
			}
			else if (value instanceof Double){
				size+= 8;
			}
			else if(value instanceof byte[]){
				size+= 4 + ((byte[]) value).length;
			}
			else if(value instanceof OneByteInt){
				size +=1;
			}
		}
		byte[] buffer = new byte[size];
		
		
		int index = 0;
		for(String property: properties){
			Object value = propToValue.get(property);
			if(value instanceof Integer){
				index = intToByte((Integer)value, buffer, index); /*Converts Integer to byte*/
			}
			else if(value instanceof String){
				index = intToByte(((String) value).length(), buffer, index); /*1st integer is length of string*/
				index = stringToByte(((String)value), buffer,index);		/*Convert the content of string to bytes*/
			}
			else if(value instanceof Double){
				index = doubleToByte((Double)value,buffer,index);		/*Convert double to bytes*/
			}
			else if(value instanceof byte[]){
				index = intToByte(((byte[]) value).length, buffer,index); /*First int is length of byte array*/
				System.arraycopy(value, 0, buffer, index, ((byte[])value).length); /*Copy contents of byte array into buffer*/
				index+= ((byte[]) value).length;
			}else if(value instanceof OneByteInt){
				int OBIValue = ((OneByteInt) value).getValue();
				buffer[index++] = (byte) (OBIValue & 0xFF);
			}
			
		}
		
		return buffer;
	}
	
	private int intToByte(int i, byte[] buffer, int index){
		/*buffer[index++] = (byte)((i>>24) & 0xFF);
		buffer[index++] = (byte)((i>>16) & 0xFF);
		buffer[index++] = (byte)((i>>8) & 0xFF);
		buffer[index++] = (byte)((i) & 0xFF);*/
		
		byte[] temp = new byte[4];
		ByteBuffer.wrap(temp).putInt(i);
		for(byte b: temp){
			buffer[index++] = b;
		}
		
		return index;
	}
	private int stringToByte(String s, byte[] buffer, int index){
		for(byte b: s.getBytes()){
			buffer[index++] = b;
		}
		return index;
	}
	private int doubleToByte(Double d, byte[] buffer, int index){
		byte[] temp = new byte[8];
		ByteBuffer.wrap(temp).putDouble(d);
		for(byte b: temp){
			buffer[index++] = b;
		}
		return index;
	}
	
	/***
	 * Builder class for BytePackerClass
	 * 
	 * 
	 */
	public static class Builder{
		private BytePacker packer;
		
		public Builder(){
			packer = new BytePacker();
		}
		
		public Builder setProperty(String key, int value){
			return set(key,value);
		}
		
		public Builder setProperty(String key, double value){
			return set(key, value);
		}
		
		public Builder setProperty(String key, String string){
			return set(key, string);
		}
		
		public Builder setProperty(String key, OneByteInt value){
			return set(key,value);
		}
		
		public Builder set(String key, Object value){
			packer.setValue(key,value);
			return this;
		}
		
		
		public BytePacker build(){
			return packer;
		}
	}
}

package main;

import java.io.IOException;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.Scanner;

import bank.Bank;
import services.BalanceTransfer;
import services.BalanceUpdate;
import services.CallbackHandlerClass;
import services.CheckBalanceService;
import services.CloseAccountService;
import services.CreateAccountService;
import services.RegisterCallbackService;
import socket.NormalSocket;
import socket.Socket;

public class ServerApplication {
	private static Server server;
	private static Bank bank;
	private static CallbackHandlerClass callbackHandler;
	private static InetAddress address;
	private static Socket socket;
	private static int portNumber;
	public static void main(String[] args){
		Console console = new Console(new Scanner(System.in));
		try {
			System.out.println("Starting server");
			bank = new Bank();
			
			/*Start of code to set server configurations*/
			String addressInput = console.askForString("Input IP address hosting server on:");
			address = InetAddress.getByName(addressInput);
			portNumber = console.askForInteger("Input port number for server to listen at:");
			socket = new NormalSocket(new DatagramSocket(portNumber,address));
			/*Specify type of server*/
			int serverChoice = console.askForInteger(1, 2, "Select Server type: \n1)At-Least-Once\n2)At-Most-Once");
			if(serverChoice==1){
				server = new Server(socket); //at-least-once server
			}
			else if(serverChoice==2){
				server = new AtMostOnceServer(socket); //at-most-once server
			}
			/*Specify what type of socket to use*/
			int socketType = console.askForInteger(1, 2, "Select Socket Type: \n1)Normal Socket\n2SendingLossSocket");
			 if(socketType==2){
				double probability = 1 - console.askForDouble(0.0, 1.0, "Probability of packetloss:");
				server.useSendingLossSocket(probability);
			 }			
			//Console.debug_info = false;		
			
			/*End of code to set server configurations*/	
			
			callbackHandler = new CallbackHandlerClass(socket);
			Thread validityCheck = new Thread(callbackHandler);
			validityCheck.start();
			//Services to be added to server
			server.addServiceToServer(0, new CreateAccountService(callbackHandler));
			server.addServiceToServer(1, new CloseAccountService(callbackHandler));
			server.addServiceToServer(2, new BalanceUpdate(callbackHandler));
			server.addServiceToServer(3, new BalanceTransfer(callbackHandler));
			server.addServiceToServer(4, new RegisterCallbackService(callbackHandler));
			server.addServiceToServer(5, new CheckBalanceService(callbackHandler));
			////////////////
			server.start();
		} catch (SocketException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			Console.debug("Server error");
			e.printStackTrace();
		} 
		
	}
	
}
package main;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import message.BytePacker;

public class History {
	private ArrayList<Client> clientList;
	public static final int HISTORY_RECORD_SIZE = 10;
	
	public History(){
		clientList = new ArrayList<>();
	}
	
	
	
	/**
	 * searches for existing client in clientList, else create a new client and insert into list
	 * @param address ipaddress
	 * @param port portnumber
	 * @return client object
	 */
	public Client findClient(InetAddress address, int port){
		for(Client c : clientList){
			if(c.address.equals(address) && c.portNumber==port){
				return c;
			}
		}
		Client newClient = new Client(address, port);
		clientList.add(newClient);
		return newClient;
	}
	

	
	
	/**
	 * Represents each client that has sent the server a request before. 
	 */
	public class Client{
		private InetAddress address;
		private int portNumber;
		private HashMap<Integer, BytePacker> messageIdToReplyMap;
		private int[] historyRecord;
		private int count;
		public Client(InetAddress address, int portNumber){
			this.address = address;
			this.portNumber = portNumber;
			this.messageIdToReplyMap = new HashMap<>();
			historyRecord = new int[HISTORY_RECORD_SIZE]; //keep 10 messages in history
			count = 0;
			Arrays.fill(historyRecord, -1);
			
		}
		public BytePacker searchForDuplicateRequest(int messageId){
			BytePacker reply = this.messageIdToReplyMap.get(messageId);
			if(reply!=null){
				Console.debug("Request already serviced. Resending reply");
			}
			return reply;
		}
		public void addServicedReqToMap(int messageId, BytePacker replyToServicedReq) {
			if(historyRecord[count] !=-1){
				messageIdToReplyMap.remove(historyRecord[count]);
			}
			this.messageIdToReplyMap.put(messageId, replyToServicedReq);
			historyRecord[count] = messageId; 
			count = (count + 1) % HISTORY_RECORD_SIZE;
			
		}
	}


	
}
package main;
import java.util.Scanner;

/***
 * This class is in charged of printing results on the console.
 * 
 * @author Shide
 *
 */
public class Console {
	private Scanner scanner;
	static boolean debug_info = true;

	public Console(Scanner scanner) {
		this.scanner = scanner;
	}

	public static void println(String str) {
		System.out.println(str);
	}

	public static void debug(String str) {
		if (debug_info)
			System.out.println(str);
	}

	/**
	 * Prompt User to key in integer of choices
	 *
	 * @param question
	 *            A string of question to ask user for input
	 * @return user input
	 */
	public int askForInteger(String question) {
		System.out.println(question);
		return askForInteger();
	}

	/**
	 * This method read Client's input of integer
	 *
	 * @return Integer if user key in correctly, error message otherwise
	 */
	public int askForInteger() {
		while (true) {
			try {
				return Integer.parseInt(scanner.nextLine());
			} catch (NumberFormatException ignored) {
			}
		}
	}

	public double askForDouble(String question) {
		System.out.println(question);
		return askForDouble();
	}

	public double askForDouble() {
		while (true) {
			try {
				return Double.parseDouble(scanner.nextLine());
			} catch (NumberFormatException ignored) {
			}
		}
	}

	public String askForString(String question) {
		System.out.println(question);
		return scanner.nextLine();
	}
	
	public int askForInteger(int min, int max, String question){
		System.out.println(question);
		int choice = min;
		while(true){
			try{
				choice = Integer.parseInt(scanner.nextLine());
				if(choice >= min && choice <=max){
					return choice;
				}
				else{
					System.out.println("Invalid Choice");
					System.out.println(question);
				}
			}catch(NumberFormatException ignored){}
		}
	}
	public double askForDouble(double min, double max, String question){
		System.out.println(question);
		double choice = min;
		while(true){
			try{
				choice = Double.parseDouble(scanner.nextLine());
				if(choice >= min && choice <=max){
					return choice;
				}
				else{
					System.out.println("Invalid Choice");
					System.out.println(question);
				}
			}catch(NumberFormatException ignored){}
		}
	}
	
	
}
package main;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Arrays;
import java.util.HashMap;

import message.BytePacker;
import services.CallbackHandlerClass;
import services.Service;
import socket.NormalSocket;
import socket.ReceivingLossSocket;
import socket.SendingLossSocket;
import socket.Socket;

public class Server {
	protected HashMap<Integer, Service> idToServiceMap;
	protected Socket designatedSocket;
	protected int portNumber;
	protected String ipAddress;
	protected final int bufferSize = 2048;
	protected byte[] buffer;
	
	public Server(Socket socket) throws SocketException{
		this.idToServiceMap = new HashMap<>();
		this.designatedSocket = socket;
		this.buffer = new byte[bufferSize];
		
		
	}
	
	public void addServiceToServer(int id, Service service){
		if(!this.idToServiceMap.containsKey(id)){
			this.idToServiceMap.put(id, service);
			System.out.println("Service added");
		}
		else{
			System.out.printf("There is no existing service using service id %d, please use a different id.\n",id);
		}		
	}
	
	@SuppressWarnings("finally")
	public void start(){
		while(true){
			try{
				DatagramPacket p = receive(); 
				if(p.getLength()!=0){
					byte[] data = p.getData();
					InetAddress clientAddress = p.getAddress();
					int clientPortNumber = p.getPort();
					//Service ID from client is the first byte in the byte array sent from client
					int serviceRequested = data[0];
					Service service = null;
					if(idToServiceMap.containsKey(serviceRequested)){
						service = idToServiceMap.get(serviceRequested);
						System.out.println("Service Requested: " + service.ServiceName());
						BytePacker replyToRequest = service.handleService(clientAddress,clientPortNumber, data, this.designatedSocket);
						this.designatedSocket.send(replyToRequest, clientAddress, clientPortNumber);					
					}	
				}
			}catch(IOException e){
				e.printStackTrace();
				
			}catch(NullPointerException e){
				Console.debug("Received corrupted data");
				e.printStackTrace();
			}finally{
				continue;
			}	
		}
	}
	
	public DatagramPacket receive() throws IOException{
		Arrays.fill(buffer, (byte) 0);	//empty buffer
		DatagramPacket p = new DatagramPacket(buffer, buffer.length);
		//System.out.println("Waiting for request...");
		this.designatedSocket.receive(p);
		
		return p;
	}
	
	public void useSendingLossSocket(double probability){
		this.designatedSocket = new SendingLossSocket(this.designatedSocket, probability);
	}
	public void useReceivingLossSocket(double probability){
		this.designatedSocket = new ReceivingLossSocket(this.designatedSocket, probability);
	}
}
package main;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;
import java.util.Arrays;

import main.History.Client;
import message.BytePacker;
import message.ByteUnpacker;
import services.Service;
import socket.Socket;

public class AtMostOnceServer extends Server {
	
	private History history;

	public AtMostOnceServer(Socket socket) throws SocketException {
		super(socket);
		history = new History();
		// TODO Auto-generated constructor stub
	}
	
	public void start(){
		while(true){
			try{
				DatagramPacket p = receive(); /*Create DatagramPacket to receive requests from clients, assumes that it has no problem receiving.*/
				if(p.getLength()!=0){
					byte[] data = p.getData();
					InetAddress clientAddress = p.getAddress();
					int clientPortNumber = p.getPort();
					//Service ID from client is the first byte in the byte array sent from client
					int serviceRequested = data[0];
					Service service = null;
					if(idToServiceMap.containsKey(serviceRequested)){
						service = idToServiceMap.get(serviceRequested);
						ByteUnpacker.UnpackedMsg unpackedMsg = service.getUnpacker().parseByteArray(data);
						int messageId = unpackedMsg.getInteger(Service.getMessageId());
						Client client = history.findClient(clientAddress, clientPortNumber);
						BytePacker replyToServicedReq = client.searchForDuplicateRequest(messageId);
						if(replyToServicedReq == null){
							replyToServicedReq = service.handleService(clientAddress, clientPortNumber, data, this.designatedSocket);
							client.addServicedReqToMap(messageId, replyToServicedReq);
						}
						this.designatedSocket.send(replyToServicedReq, clientAddress, clientPortNumber);
					}	
				}
			}catch(IOException e){
				e.printStackTrace();
			}catch(NullPointerException e){
				e.printStackTrace();
			}finally{
				continue;
			}
		}
	}
	

	

}
package services;

import java.io.IOException;
import java.net.InetAddress;

import bank.Bank;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.Socket;

public class BalanceUpdate extends Service {
	protected final static String NAME = "Name";
	protected final static String ACCNUM = "accNum";
	protected final static String PIN = "Pin";
	protected final static String CHOICE = "choice";
	protected final static String AMOUNT = "amount";
	private CallbackHandlerClass callbackHandler;
	public BalanceUpdate(CallbackHandlerClass callbackHandler){
		super(new ByteUnpacker.Builder()
						.setType(NAME, ByteUnpacker.TYPE.STRING)
						.setType(ACCNUM, ByteUnpacker.TYPE.INTEGER)
						.setType(PIN, ByteUnpacker.TYPE.INTEGER)
						.setType(CHOICE, ByteUnpacker.TYPE.INTEGER)
						.setType(AMOUNT, ByteUnpacker.TYPE.DOUBLE)
						.build());	
		this.callbackHandler = callbackHandler;
	}
	
	
	@Override
	public BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient, Socket socket) {
		// TODO Auto-generated method stub
		ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(dataFromClient);
		String accHolderName = unpackedMsg.getString(NAME);
		int accNum = unpackedMsg.getInteger(ACCNUM);
		int accPin = unpackedMsg.getInteger(PIN);
		int choice = unpackedMsg.getInteger(CHOICE);
		double amount = unpackedMsg.getDouble(AMOUNT);
		int messageId = unpackedMsg.getInteger(super.getMessageId());
		String reply = "";
		double accBalance = Bank.updateBalance(accHolderName,accNum, accPin, choice, amount);
		OneByteInt status = new OneByteInt(0);
		if(accBalance==-1){
			reply = "Invalid account number. Please try again.";
		}
		else if(accBalance ==-2){
			reply = "Invalid pin number . Please try again";
		}
		else if(accBalance==-3){
			reply = "Insufficient funds. Current balance: " + Bank.checkBalance(accNum, accPin);
		}
		else if(accBalance==-4){
			reply = "Invalid Choice. Please try again";
		}
		else{
			reply = String.format("---------------------\nWithdraw funds  \nAmount Withdrawn: %f \nCurrent account balance: %f\n------------------" , amount, accBalance);
			BytePacker replyMessageSubscriber = super.generateReply(status, messageId, reply);
			callbackHandler.broadcast(replyMessageSubscriber);
		}
		
		BytePacker replyMessageClient = super.generateReply(status, messageId, reply);
		return replyMessageClient;
		
	}

	@Override
	public String ServiceName() {
		return "Make Deposit/Withdrawal";
	}
	
	
}
package services;


import java.io.IOException;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import main.Console;
import message.BytePacker;
import message.OneByteInt;
import socket.Socket;

public class CallbackHandlerClass implements Runnable {
	private Socket designatedSocket;
	private static ArrayList<Subscriber> allTheSubscribers;
	
	public CallbackHandlerClass(Socket designatedSocket){
		this.designatedSocket = designatedSocket;
		allTheSubscribers = new ArrayList<>();
		
	}
	
	public void registerSubscriber(InetAddress address, int portNumber, int messageId, int timeout){
		Subscriber subscriber = new Subscriber(address, portNumber, messageId, timeout);
		
		//Check if client has already subscribed to callbackService or not 
		if(checkExisting(address,portNumber,messageId,timeout)){
			allTheSubscribers.add(subscriber); 
			Console.debug("New subscriber added");
			subscriber.printSubscriberInfo();
		}
		else{
			Console.debug("Client exists in list of subscribers");
		}
		
	}
	
	public boolean checkExisting(InetAddress address, int portNumber, int messageId, int timeout){
		//Console.debug("Check Existing");
		boolean DoesNotExists = true; //set to true, means no such subscriber
		for(Subscriber s: allTheSubscribers){
			s.printSubscriberInfo();
			if(s.address.equals(address) && s.portNumber==portNumber && s.messageId == messageId){
				DoesNotExists = false;
				break;
			}
		}
		return DoesNotExists;
	}
	
	
	public void checkValidity() throws IOException{
		Date now = new GregorianCalendar().getTime();
		ArrayList<Subscriber> temp = new ArrayList<>();
		for (Subscriber s: allTheSubscribers){
			if(now.after(s.expireTime.getTime())){
				Console.debug("Removing:");
				s.printSubscriberInfo();
				//Before removing, need to send termination message!
				OneByteInt status = new OneByteInt(4);
				sendTerminationMessage(s,status);
				temp.add(s);
			}
		}
		for(Subscriber x: temp){
			if(allTheSubscribers.contains(x)){
				allTheSubscribers.remove(x);
			}
		}
	}
	
	public void sendTerminationMessage(Subscriber s,OneByteInt status) throws IOException{
		Console.debug("Sending termination message");
		String reply = "Auto monitoring expired.";
		//System.out.println("subscriber messageId: " + s.messageId);
		BytePacker replyMessage = new BytePacker.Builder()
				.setProperty(Service.STATUS, status)
				.setProperty(Service.getMessageId(), s.messageId)
				.setProperty(Service.REPLY, reply)
				.build();
		designatedSocket.send(replyMessage, s.address, s.portNumber);
	}
	
	public void broadcast(BytePacker msg){
		try {
			checkValidity();
			if(((OneByteInt)msg.getPropToValue().get(Service.getStatus())).getValue()==0){ //Only if reply status is 0, then broadcast out. 
				if(!allTheSubscribers.isEmpty()){
					Console.debug("Sending packets to subscribers:");
					for (Subscriber s: allTheSubscribers){
						msg.getPropToValue().put(Service.getMessageId(), s.messageId); //replace msgId of reply to whoever that made the action of with msgId of subscriber.
						designatedSocket.send(msg, s.address, s.portNumber);
					}
				}
				
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			System.out.println("Error broadcasting");
			e.printStackTrace();
		}
		
		
	}
	@Override
	public void run() {
		while(true){
			try {
				//Check validity every 20s on separate thread.
				checkValidity();
				Thread.sleep(20);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		
	}
	
	public static class Subscriber{
		private InetAddress address;
		private int portNumber;
		private Calendar expireTime;
		private int messageId; //Store messageId, such that each msg(the update) sent to subscriber has same msgId of request? Hmmmm okay.
		//think of a way to manage monitor interval. timeout should be associated with Subscriber object. 
		//private 
		public Subscriber(InetAddress address, int portNumber, int messageId, int timeLimit){
			this.address = address;
			this.portNumber = portNumber;
			this.messageId = messageId;
			
			//Calculate time to remove subscriber.
			expireTime = Calendar.getInstance();
			expireTime.add(Calendar.MINUTE, timeLimit);
			Console.debug("expireTime: " + expireTime.getTime());
		}
		
		
		public void printSubscriberInfo(){
			Console.debug("Address: " + address.toString() + ", portNumber: " + portNumber + ", messageId: " + messageId + ", expireTime: " + expireTime.getTime());
		}
	}

	

	

}
package services;

import java.io.IOException;
import java.net.InetAddress;

import bank.Bank;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.Socket;

public class CreateAccountService extends Service {
	protected final static String NAME = "Name";
	protected final static String PIN = "Pin";
	protected final static String CURRENCY = "Currency";
	protected final static String BALANCE = "Balance";
	private CallbackHandlerClass callbackHandler;
	//private CallbackHandlerClass callbackHandler;
	public CreateAccountService(CallbackHandlerClass callbackHandler){
		super(new ByteUnpacker.Builder()
						.setType(NAME, ByteUnpacker.TYPE.STRING)
						.setType(PIN, ByteUnpacker.TYPE.INTEGER)
						.setType(CURRENCY, ByteUnpacker.TYPE.STRING)
						.setType(BALANCE, ByteUnpacker.TYPE.DOUBLE)
						.build());
		this.callbackHandler = callbackHandler;
		//this.callbackHandler = callbackHandler;
						
	}
	
	@Override
	public BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient, Socket socket) {

		ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(dataFromClient);
		String accHolderName = unpackedMsg.getString(NAME);
		int accPin = unpackedMsg.getInteger(PIN);
		String accCurrency = unpackedMsg.getString(CURRENCY);
		double accBalance = unpackedMsg.getDouble(BALANCE);
		int messageId = unpackedMsg.getInteger(super.getMessageId());
		int accNum = Bank.createAccount(accHolderName, accPin, accCurrency, accBalance);
		
		OneByteInt status = new OneByteInt(0); 
		String reply = String.format("Account created ----------- \n Account Holder name: %s \n Account number: %d \n Currency: %s \n Balance: %f \n --------- ",accHolderName, accNum, accCurrency, accBalance);
		BytePacker replyMessageClient = super.generateReply(status, messageId, reply);
		
		String toSubscribers = String.format("%s created an account. Account number: %d", accHolderName, accNum);
		BytePacker replyMessageSubscribers = super.generateReply(status, messageId, toSubscribers);
		callbackHandler.broadcast(replyMessageSubscribers);
		return replyMessageClient;
		
		
	}

	@Override
	public String ServiceName() {
		return "Create Account";
	}
}
package services;

import java.net.InetAddress;

import bank.Bank;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.Socket;

public class CheckBalanceService extends Service {
	protected final static String ACC_NUMBER = "AccountNumber";
	protected final static String PIN = "Pin";
	private CallbackHandlerClass callbackHandler;

	public CheckBalanceService(CallbackHandlerClass callbackHandler) {
		super(new ByteUnpacker.Builder()
				.setType(ACC_NUMBER,ByteUnpacker.TYPE.INTEGER)
				.setType(PIN, ByteUnpacker.TYPE.INTEGER)
				.build());
		this.callbackHandler = callbackHandler;
		
	}

	@Override
	public BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient,
			Socket socket) {
		ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(dataFromClient);
		int accNum = unpackedMsg.getInteger(ACC_NUMBER);
		int pin = unpackedMsg.getInteger(PIN);
		int messageId = unpackedMsg.getInteger(getMessageId());
		double balance = Bank.checkBalance(accNum,pin);
		String reply = "";
		OneByteInt status = new OneByteInt(0);
		if(balance == -1){
			reply = "Invalid account number. Please try again.";
		}
		else if(balance == -2){
			reply = "Invalid pin number . Please try again";
		}
		else{
			reply = String.format("------------------------------\nAcc Number: %d\nCurrent account balance: %.2f\n------------------",accNum,  balance);
			BytePacker replyMessageSubscriber = super.generateReply(status, messageId, reply);
			callbackHandler.broadcast(replyMessageSubscriber);
		}
		BytePacker replyMessageClient = super.generateReply(status, messageId, reply);
		
		return replyMessageClient;
	}

	@Override
	public String ServiceName() {
		return "Check Balance";
	}
	
}
package services;

import java.io.IOException;
import java.net.InetAddress;

import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.Socket;

public abstract class Service {
	
	/*
	 * Need to come up with a list of statuses that are standardized!!!
	 * 0 - success
	 * 1 - Fail
	 * 2 - Auto monitoring update
	 * 4 - Auto monitoring expired
	 * */
	private ByteUnpacker unpacker;
	protected static final String SERVICE_ID = "serviceId";
	private static final String MESSAGE_ID = "messageId";
	protected static final String STATUS = "status";
    protected static final String REPLY = "reply";
    
	public Service(ByteUnpacker unpacker){
		this.setUnpacker(new ByteUnpacker.Builder()
						.setType(SERVICE_ID, ByteUnpacker.TYPE.ONE_BYTE_INT)
						.setType(getMessageId(), ByteUnpacker.TYPE.INTEGER)
						.build()
						.defineComponents(unpacker));
	}
	
	public BytePacker generateReply(OneByteInt status, int messageId, String reply){
		BytePacker replyMessage = new BytePacker.Builder()
							.setProperty(STATUS, status)
							.setProperty(getMessageId(), messageId)
							.setProperty(REPLY, reply)
							.build();
		return replyMessage;
	}
	public static String getStatus(){
		return STATUS;
	}
	
	public abstract BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient, Socket socket) throws IOException, NullPointerException;
	public abstract String ServiceName();

	public ByteUnpacker getUnpacker() {
		return unpacker;
	}

	public void setUnpacker(ByteUnpacker unpacker) {
		this.unpacker = unpacker;
	}

	public static String getMessageId() {
		return MESSAGE_ID;
	}
}
package services;

public class ErrorHandler {

}
package services;

import java.net.InetAddress;

import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import services.CallbackHandlerClass.Subscriber;
import socket.Socket;

public class RegisterCallbackService extends Service {
	
	protected final static String TIMEOUT = "timeout";
	private CallbackHandlerClass callbackHandler;
	public RegisterCallbackService(CallbackHandlerClass callbackHandler) {
		super(new ByteUnpacker.Builder()
				.setType(TIMEOUT, ByteUnpacker.TYPE.INTEGER)
				.build());
		this.callbackHandler = callbackHandler; 
		
	}

	@Override
	public BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient,
			Socket socket) {
		//clientAddress, portnumber not in used at the moment...used to check at most once semantics/at least once? Hmmm
		ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(dataFromClient);
		int messageId = unpackedMsg.getInteger(Service.getMessageId());
		int timeout = unpackedMsg.getInteger(TIMEOUT);
		//Create subscriber object
		callbackHandler.registerSubscriber(clientAddress, clientPortNumber, messageId, timeout);
		OneByteInt status = new OneByteInt(0);
		String reply = "Auto-monitoring registered, waiting for updates...";
		BytePacker replyMessage = super.generateReply(status, messageId, reply);
		return replyMessage;
		
	}

	@Override
	public String ServiceName() {
		return "Register Callback";
	}

}
package services;

import java.io.IOException;
import java.net.InetAddress;

import bank.Bank;
import main.Console;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.Socket;

public class CloseAccountService extends Service {
	protected final static String NAME = "Name";
	protected final static String PIN = "Pin";
	protected final static String ACCNUM = "accNum";
	private CallbackHandlerClass callbackHandler;
	//private CallbackHandlerClass callbackHandler;
	public CloseAccountService(CallbackHandlerClass callbackHandler){
		super(new ByteUnpacker.Builder()
						.setType(NAME, ByteUnpacker.TYPE.STRING)
						.setType(ACCNUM, ByteUnpacker.TYPE.INTEGER)
						.setType(PIN, ByteUnpacker.TYPE.INTEGER)
						.build());
		this.callbackHandler = callbackHandler;
		//this.callbackHandler = callbackHandler;
						
	}
	
	@Override
	public BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient, Socket socket) {
		String reply = "";
		ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(dataFromClient);
		String accHolderName = unpackedMsg.getString(NAME);
		int accNum = unpackedMsg.getInteger(ACCNUM);
		int accPin = unpackedMsg.getInteger(PIN);
		Console.debug("accNum: " + accNum);
		int messageId = unpackedMsg.getInteger(super.getMessageId());
		int ret = Bank.closeAccount(accHolderName,accNum ,accPin);
		OneByteInt status = new OneByteInt(0); 
		if (ret == 1){
			reply = String.format("---------------\nAccount %d successfully deleted\n--------------- ", accNum);
			BytePacker replyMessageSubscribers = super.generateReply(status, messageId, reply);
			callbackHandler.broadcast(replyMessageSubscribers);
		}
		else if(ret==-1){
			 reply = String.format("Invalid Account Number. Please try again.");
		}
		else if(ret == -2){
			reply = String.format("Invalid Pin number. Please try again");
		}
		
		BytePacker replyMessageClient = super.generateReply(status, messageId, reply);
		
		return replyMessageClient;
	}
	
	
	@Override
	public String ServiceName() {
		return "Close Account";
	}
}
package services;

import java.io.IOException;
import java.net.InetAddress;

import bank.Bank;
import message.BytePacker;
import message.ByteUnpacker;
import message.OneByteInt;
import socket.Socket;

public class BalanceTransfer extends Service {
	protected final static String NAME = "Name";
	protected final static String ACCNUM = "accNum";
	protected final static String PIN = "Pin";
	protected final static String RECEIVER = "receiver";
	protected final static String AMOUNT = "amount";
	private CallbackHandlerClass callbackHandler;
	public BalanceTransfer(CallbackHandlerClass callbackHandler){
		super(new ByteUnpacker.Builder()
						.setType(NAME, ByteUnpacker.TYPE.STRING)
						.setType(ACCNUM, ByteUnpacker.TYPE.INTEGER)
						.setType(PIN, ByteUnpacker.TYPE.INTEGER)
						.setType(RECEIVER, ByteUnpacker.TYPE.INTEGER)
						.setType(AMOUNT, ByteUnpacker.TYPE.DOUBLE)
						.build());		
		this.callbackHandler = callbackHandler;
	}	
	
	@Override
	public BytePacker handleService(InetAddress clientAddress, int clientPortNumber, byte[] dataFromClient, Socket socket) {
		String reply = "";
		ByteUnpacker.UnpackedMsg unpackedMsg = this.getUnpacker().parseByteArray(dataFromClient);
		String accHolderName = unpackedMsg.getString(NAME);
		int accNum = unpackedMsg.getInteger(ACCNUM);
		int accPin = unpackedMsg.getInteger(PIN);
		int receiver = unpackedMsg.getInteger(RECEIVER);
		double amount = unpackedMsg.getDouble(AMOUNT);
		int messageId = unpackedMsg.getInteger(super.getMessageId());
		
		double accBalance = Bank.transferBalance(accHolderName, accNum, receiver, accPin, amount);
		OneByteInt status = new OneByteInt(0);
		if(accBalance==-1){
			reply = "Invalid account number. ";
		}
		else if (accBalance == -2){
			reply = "Invalid pin number . Please try again";
		}
		else if(accBalance==-3){
			reply = "Insufficient funds. Current balance: " + Bank.checkBalance(accNum, accPin);
		}
		else{
			reply = String.format("--------------------\nFunds Transfer\nFrom: %d\nTo: %d\nAmount:%.2f\nBalance: %.2f\n---------------", accNum,receiver,amount,accBalance);
			String replyToSubscribers = String.format("%.2f transferred from acc number: %d to acc number: %d", amount, accNum,receiver);
			BytePacker replyMessageToSubcribers = super.generateReply(status, messageId, replyToSubscribers);
			callbackHandler.broadcast(replyMessageToSubcribers);
			
		}
		BytePacker replyMessage = super.generateReply(status, messageId, reply);
		return replyMessage;
		
	}
	public String ServiceName(){
		return "Transfer funds";
	}
}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;

import message.BytePacker;

public class WrapperSocket implements Socket {
	private final Socket socket;
	
	public WrapperSocket(Socket socket){
		this.socket = socket;
	}
	
	@Override
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {

		this.socket.send(msg, address, port);
		
	}

	@Override
	public void receive(DatagramPacket p) throws IOException {
		this.socket.receive(p);
	}

	@Override
	public void close() {
		this.socket.close();
		
	}

	@Override
	public void setTimeOut(int timeout) throws SocketException {
		// TODO Auto-generated method stub
		this.socket.setTimeOut(timeout);
		
	}

}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.SocketTimeoutException;
import java.util.Random;

import main.Console;

/**
 * Simulate packet loss when receiving
 * 
 * @author Shide
 *
 */
public class ReceivingLossSocket extends WrapperSocket {
	private Random random;
	private double probability;
	
	public ReceivingLossSocket(Socket socket, double probability){
		super(socket);
		this.random = new Random();
		this.probability = probability;
	}
	
	public void receive(DatagramPacket p) throws IOException, SocketTimeoutException{
		if(random.nextDouble()<this.probability){
			super.receive(p);
		}
		else{
			try {
				Thread.sleep(1000);
				Console.debug("Simulate packetloss when receiving");
			} catch (InterruptedException e) {
				e.printStackTrace();
			}throw new SocketTimeoutException();
		}
	}
}
package socket;

import java.io.IOException;
import java.net.InetAddress;
import java.util.Random;

import main.Console;
import message.BytePacker;

/**
 * 
 * Simulate packet loss when sending packets out, based on a defined probability
 * @author Shide
 *
 */
public class SendingLossSocket extends WrapperSocket {
	
	private final Random random;
	private final double probability;
	public SendingLossSocket(Socket socket, double probability) {
		super(socket);
		this.random = new Random();
		this.probability = probability;
		// TODO Auto-generated constructor stub
	}
	
	/**
	 * Use probability to simulate packetloss
	 * higher prob --> higher probability of sending. lower packetloss
	 * 
	 */
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {
		if(random.nextDouble()<1-probability){
			super.send(msg, address, port);
		}
		else{
			try{
				Thread.sleep(1000);
				Console.debug("Simulate Packet loss");
			}catch(InterruptedException e){
				e.printStackTrace();
			}
		}
	}
	

}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.SocketException;

import message.BytePacker;

public interface Socket {
	void send(BytePacker msg ,InetAddress address, int port) throws IOException;
	void receive(DatagramPacket p) throws IOException;
	void close();
	void setTimeOut(int timeout) throws SocketException;
}
package socket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

import main.Console;
import message.BytePacker;

public class NormalSocket implements Socket {
	
	private DatagramSocket socket;
	
	public NormalSocket(DatagramSocket socket){
		this.socket = socket;
	}
	
	@Override
	public void send(BytePacker msg, InetAddress address, int port) throws IOException {
		Console.debug("InetAddress: "+ address + ", Port: " + port);
		byte[] message = msg.getByteArray();
		DatagramPacket p = new DatagramPacket(message, message.length,address, port);
		send(p);
		return;
	}

	@Override
	public void receive (DatagramPacket p) throws IOException {
		// TODO Auto-generated method stub
		this.socket.receive(p);
		return;
	}

	@Override
	public void close() {
		// TODO Auto-generated method stub
		this.socket.close();
		return;
	}

	@Override
	public void setTimeOut(int timeout) throws SocketException {
		this.socket.setSoTimeout(timeout);
		return;
	}

	public DatagramSocket getSocket() {
		return socket;
	}

	public void setSocket(DatagramSocket socket) {
		this.socket = socket;
	}
	
	public void send(DatagramPacket p) throws IOException{
		this.socket.send(p);
	}
	
	
}
